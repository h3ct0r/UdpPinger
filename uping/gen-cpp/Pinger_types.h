/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Pinger_TYPES_H
#define Pinger_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace facebook { namespace netnorad { namespace thrift {

class TargetList;

class Target;

class Config;

class SiteInfo;

class Metadata;

class Metrics;

class TestResult;

typedef struct _TargetList__isset {
  _TargetList__isset() : target_list(false) {}
  bool target_list :1;
} _TargetList__isset;

class TargetList {
 public:

  TargetList(const TargetList&);
  TargetList& operator=(const TargetList&);
  TargetList() {
  }

  virtual ~TargetList() throw();
  std::vector<Target>  target_list;

  _TargetList__isset __isset;

  void __set_target_list(const std::vector<Target> & val);

  bool operator == (const TargetList & rhs) const
  {
    if (!(target_list == rhs.target_list))
      return false;
    return true;
  }
  bool operator != (const TargetList &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TargetList & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TargetList &a, TargetList &b);

inline std::ostream& operator<<(std::ostream& out, const TargetList& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Target__isset {
  _Target__isset() : hostname(false), clustertype(false), ignore(false), cluster(false), v4(false), v6(false), pod(false), rack(false) {}
  bool hostname :1;
  bool clustertype :1;
  bool ignore :1;
  bool cluster :1;
  bool v4 :1;
  bool v6 :1;
  bool pod :1;
  bool rack :1;
} _Target__isset;

class Target {
 public:

  Target(const Target&);
  Target& operator=(const Target&);
  Target() : hostname(), clustertype(), ignore(0), cluster(), v4(), v6(), pod(), rack() {
  }

  virtual ~Target() throw();
  std::string hostname;
  std::string clustertype;
  bool ignore;
  std::string cluster;
  std::string v4;
  std::string v6;
  std::string pod;
  std::string rack;

  _Target__isset __isset;

  void __set_hostname(const std::string& val);

  void __set_clustertype(const std::string& val);

  void __set_ignore(const bool val);

  void __set_cluster(const std::string& val);

  void __set_v4(const std::string& val);

  void __set_v6(const std::string& val);

  void __set_pod(const std::string& val);

  void __set_rack(const std::string& val);

  bool operator == (const Target & rhs) const
  {
    if (!(hostname == rhs.hostname))
      return false;
    if (!(clustertype == rhs.clustertype))
      return false;
    if (!(ignore == rhs.ignore))
      return false;
    if (!(cluster == rhs.cluster))
      return false;
    if (!(v4 == rhs.v4))
      return false;
    if (!(v6 == rhs.v6))
      return false;
    if (!(pod == rhs.pod))
      return false;
    if (!(rack == rhs.rack))
      return false;
    return true;
  }
  bool operator != (const Target &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Target & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Target &a, Target &b);

inline std::ostream& operator<<(std::ostream& out, const Target& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Config__isset {
  _Config__isset() : ignore_my_samples(true), pinger_cooldown_time(true), pinger_rate(true), pinger_target_port(true), pinger_sender_threads(true), pinger_receiver_threads(true), dead_racks_threshold(true), base_src_port(true), src_port_count(true), socket_buffer_size(true) {}
  bool ignore_my_samples :1;
  bool pinger_cooldown_time :1;
  bool pinger_rate :1;
  bool pinger_target_port :1;
  bool pinger_sender_threads :1;
  bool pinger_receiver_threads :1;
  bool dead_racks_threshold :1;
  bool base_src_port :1;
  bool src_port_count :1;
  bool socket_buffer_size :1;
} _Config__isset;

class Config {
 public:

  Config(const Config&);
  Config& operator=(const Config&);
  Config() : ignore_my_samples(0), pinger_cooldown_time(2), pinger_rate(500000), pinger_target_port(65534), pinger_sender_threads(2), pinger_receiver_threads(8), dead_racks_threshold(4), base_src_port(25000), src_port_count(256), socket_buffer_size(4000000) {
  }

  virtual ~Config() throw();
  int32_t ignore_my_samples;
  int32_t pinger_cooldown_time;
  int32_t pinger_rate;
  int32_t pinger_target_port;
  int32_t pinger_sender_threads;
  int32_t pinger_receiver_threads;
  int32_t dead_racks_threshold;
  int32_t base_src_port;
  int32_t src_port_count;
  int32_t socket_buffer_size;

  _Config__isset __isset;

  void __set_ignore_my_samples(const int32_t val);

  void __set_pinger_cooldown_time(const int32_t val);

  void __set_pinger_rate(const int32_t val);

  void __set_pinger_target_port(const int32_t val);

  void __set_pinger_sender_threads(const int32_t val);

  void __set_pinger_receiver_threads(const int32_t val);

  void __set_dead_racks_threshold(const int32_t val);

  void __set_base_src_port(const int32_t val);

  void __set_src_port_count(const int32_t val);

  void __set_socket_buffer_size(const int32_t val);

  bool operator == (const Config & rhs) const
  {
    if (!(ignore_my_samples == rhs.ignore_my_samples))
      return false;
    if (!(pinger_cooldown_time == rhs.pinger_cooldown_time))
      return false;
    if (!(pinger_rate == rhs.pinger_rate))
      return false;
    if (!(pinger_target_port == rhs.pinger_target_port))
      return false;
    if (!(pinger_sender_threads == rhs.pinger_sender_threads))
      return false;
    if (!(pinger_receiver_threads == rhs.pinger_receiver_threads))
      return false;
    if (!(dead_racks_threshold == rhs.dead_racks_threshold))
      return false;
    if (!(base_src_port == rhs.base_src_port))
      return false;
    if (!(src_port_count == rhs.src_port_count))
      return false;
    if (!(socket_buffer_size == rhs.socket_buffer_size))
      return false;
    return true;
  }
  bool operator != (const Config &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Config & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Config &a, Config &b);

inline std::ostream& operator<<(std::ostream& out, const Config& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SiteInfo__isset {
  _SiteInfo__isset() : dc(false), cluster(false), clustertype(false), pod(false), region(false), rack(false), hostname(false), hostprefix(false), ip(false) {}
  bool dc :1;
  bool cluster :1;
  bool clustertype :1;
  bool pod :1;
  bool region :1;
  bool rack :1;
  bool hostname :1;
  bool hostprefix :1;
  bool ip :1;
} _SiteInfo__isset;

class SiteInfo {
 public:

  SiteInfo(const SiteInfo&);
  SiteInfo& operator=(const SiteInfo&);
  SiteInfo() : dc(), cluster(), clustertype(), pod(), region(), rack(), hostname(), hostprefix(), ip() {
  }

  virtual ~SiteInfo() throw();
  std::string dc;
  std::string cluster;
  std::string clustertype;
  std::string pod;
  std::string region;
  std::string rack;
  std::string hostname;
  std::string hostprefix;
  std::string ip;

  _SiteInfo__isset __isset;

  void __set_dc(const std::string& val);

  void __set_cluster(const std::string& val);

  void __set_clustertype(const std::string& val);

  void __set_pod(const std::string& val);

  void __set_region(const std::string& val);

  void __set_rack(const std::string& val);

  void __set_hostname(const std::string& val);

  void __set_hostprefix(const std::string& val);

  void __set_ip(const std::string& val);

  bool operator == (const SiteInfo & rhs) const
  {
    if (!(dc == rhs.dc))
      return false;
    if (!(cluster == rhs.cluster))
      return false;
    if (!(clustertype == rhs.clustertype))
      return false;
    if (!(pod == rhs.pod))
      return false;
    if (!(region == rhs.region))
      return false;
    if (!(rack == rhs.rack))
      return false;
    if (!(hostname == rhs.hostname))
      return false;
    if (!(hostprefix == rhs.hostprefix))
      return false;
    if (!(ip == rhs.ip))
      return false;
    return true;
  }
  bool operator != (const SiteInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SiteInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SiteInfo &a, SiteInfo &b);

inline std::ostream& operator<<(std::ostream& out, const SiteInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Metadata__isset {
  _Metadata__isset() : src(false), dst(false), ipv6(false), proto(false), scope(false), tos(false), dead(false) {}
  bool src :1;
  bool dst :1;
  bool ipv6 :1;
  bool proto :1;
  bool scope :1;
  bool tos :1;
  bool dead :1;
} _Metadata__isset;

class Metadata {
 public:

  Metadata(const Metadata&);
  Metadata& operator=(const Metadata&);
  Metadata() : ipv6(0), proto(), scope(), tos(0), dead(0) {
  }

  virtual ~Metadata() throw();
  SiteInfo src;
  SiteInfo dst;
  bool ipv6;
  std::string proto;
  std::string scope;
  int32_t tos;
  bool dead;

  _Metadata__isset __isset;

  void __set_src(const SiteInfo& val);

  void __set_dst(const SiteInfo& val);

  void __set_ipv6(const bool val);

  void __set_proto(const std::string& val);

  void __set_scope(const std::string& val);

  void __set_tos(const int32_t val);

  void __set_dead(const bool val);

  bool operator == (const Metadata & rhs) const
  {
    if (!(src == rhs.src))
      return false;
    if (!(dst == rhs.dst))
      return false;
    if (!(ipv6 == rhs.ipv6))
      return false;
    if (!(proto == rhs.proto))
      return false;
    if (!(scope == rhs.scope))
      return false;
    if (!(tos == rhs.tos))
      return false;
    if (!(dead == rhs.dead))
      return false;
    return true;
  }
  bool operator != (const Metadata &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Metadata & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Metadata &a, Metadata &b);

inline std::ostream& operator<<(std::ostream& out, const Metadata& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Metrics__isset {
  _Metrics__isset() : numRecv(false), numXmit(false), avg(false), rttP90(false), rttP50(false), lossRatio(false) {}
  bool numRecv :1;
  bool numXmit :1;
  bool avg :1;
  bool rttP90 :1;
  bool rttP50 :1;
  bool lossRatio :1;
} _Metrics__isset;

class Metrics {
 public:

  Metrics(const Metrics&);
  Metrics& operator=(const Metrics&);
  Metrics() : numRecv(0), numXmit(0), avg(0), rttP90(0), rttP50(0), lossRatio(0) {
  }

  virtual ~Metrics() throw();
  int32_t numRecv;
  int32_t numXmit;
  double avg;
  double rttP90;
  double rttP50;
  double lossRatio;

  _Metrics__isset __isset;

  void __set_numRecv(const int32_t val);

  void __set_numXmit(const int32_t val);

  void __set_avg(const double val);

  void __set_rttP90(const double val);

  void __set_rttP50(const double val);

  void __set_lossRatio(const double val);

  bool operator == (const Metrics & rhs) const
  {
    if (!(numRecv == rhs.numRecv))
      return false;
    if (!(numXmit == rhs.numXmit))
      return false;
    if (!(avg == rhs.avg))
      return false;
    if (!(rttP90 == rhs.rttP90))
      return false;
    if (!(rttP50 == rhs.rttP50))
      return false;
    if (!(lossRatio == rhs.lossRatio))
      return false;
    return true;
  }
  bool operator != (const Metrics &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Metrics & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Metrics &a, Metrics &b);

inline std::ostream& operator<<(std::ostream& out, const Metrics& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TestResult__isset {
  _TestResult__isset() : timestamp(false), ignore(false), metadata(false), metrics(false), aggregated(false) {}
  bool timestamp :1;
  bool ignore :1;
  bool metadata :1;
  bool metrics :1;
  bool aggregated :1;
} _TestResult__isset;

class TestResult {
 public:

  TestResult(const TestResult&);
  TestResult& operator=(const TestResult&);
  TestResult() : timestamp(0), ignore(0), aggregated(0) {
  }

  virtual ~TestResult() throw();
  double timestamp;
  bool ignore;
  Metadata metadata;
  Metrics metrics;
  bool aggregated;

  _TestResult__isset __isset;

  void __set_timestamp(const double val);

  void __set_ignore(const bool val);

  void __set_metadata(const Metadata& val);

  void __set_metrics(const Metrics& val);

  void __set_aggregated(const bool val);

  bool operator == (const TestResult & rhs) const
  {
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(ignore == rhs.ignore))
      return false;
    if (!(metadata == rhs.metadata))
      return false;
    if (!(metrics == rhs.metrics))
      return false;
    if (!(aggregated == rhs.aggregated))
      return false;
    return true;
  }
  bool operator != (const TestResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TestResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TestResult &a, TestResult &b);

inline std::ostream& operator<<(std::ostream& out, const TestResult& obj)
{
  obj.printTo(out);
  return out;
}

}}} // namespace

#endif
